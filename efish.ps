%! 

%%% A postscript about recursive fish.

%%% DRAWING PROCEDURES

/draw-f {
  newpath
  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.45 lineto
  0.60 0.45 lineto
  0.60 0.55 lineto
  0.40 0.55 lineto
  0.40 0.70 lineto
  0.70 0.70 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-george {
  newpath

  0.00 0.55 moveto
  0.15 0.45 lineto 
  0.30 0.55 lineto
  0.40 0.50 lineto 
  0.20 0.00 lineto 

  0.00 0.80 moveto 
  0.15 0.60 lineto
  0.30 0.65 lineto
  0.40 0.65 lineto
  0.35 0.80 lineto
  0.40 1.00 lineto

  0.60 1.00 moveto 
  0.65 0.80 lineto 
  0.60 0.65 lineto 
  0.80 0.65 lineto
  1.00 0.45 lineto

  1.00 0.20 moveto 
  0.60 0.50 lineto 
  0.80 0.00 lineto

  0.40 0.00 moveto 
  0.50 0.30 lineto 
  0.60 0.00 lineto

  0.01 setlinewidth
  stroke 
} def 

/draw-hfish {
   newpath 

  % FISH SPINE 
 
   0.116  0.702 moveto 
   
   0.260  0.295 
   0.330  0.258  
   0.815  0.078 curveto 

  % LEFT FIN OUTLINE 

  -0.032  0.564 moveto 

  -0.132  0.452 
  -0.194  0.372 
  -0.250  0.250 curveto 

   0.000  0.000 lineto 

   0.250  0.250 lineto 

  % LEFT FIN DETAILS 

  -0.170  0.237 moveto

  -0.125  0.355 
  -0.065  0.405 
   0.002  0.436 curveto 

  -0.121  0.188 moveto 

  -0.060  0.300
  -0.030  0.330 
   0.040  0.375 curveto 

  -0.058  0.125 moveto 

  -0.010  0.240 
   0.030  0.280 
   0.100  0.321 curveto  
  
  -0.022  0.063 moveto 

   0.060 0.200 
   0.100 0.240 
   0.160 0.282 curveto 

  % RIGHT FIN OUTLINE

   0.234  0.798 moveto 
   
   0.340  0.792
   0.411  0.783
   0.500  0.750 curveto 

   0.500  0.500 lineto 

   0.377  0.377 lineto

  % RIGHT FIN DETAILS

   0.315  0.710 moveto 
  
   0.378  0.732 
   0.426  0.726
   0.487  0.692 curveto

   0.340  0.605 moveto 

   0.400  0.642 
   0.435  0.647 
   0.489  0.626 curveto 

   0.348  0.502 moveto 
   
   0.400  0.564 
   0.422  0.568 
   0.489  0.563 curveto 

   0.451  0.418 moveto 

   0.465  0.400
   0.480  0.385
   0.490  0.381 curveto 

   0.421  0.388 moveto 

   0.440  0.350 
   0.455  0.335 
   0.492  0.325 curveto

  % LEFT EYE

   0.053  0.658 moveto 
   
   0.042  0.710
   0.042  0.760
   0.053  0.819 curveto 

   0.085  0.812
   0.092  0.752
   0.098  0.700 curveto 

   0.085  0.687
   0.075  0.677
   0.053  0.658 curveto 

  % RIGHT EYE

   0.130  0.718 moveto 
   
   0.150  0.730
   0.175  0.745
   0.187  0.752 curveto 

   0.172  0.780 
   0.150  0.805 
   0.112  0.845 curveto 

   0.110  0.810 
   0.110  0.795 
   0.130  0.718 curveto  
    
  % MAIN FISH BODY OUTLINE

   0.000  1.000 moveto 
  -0.042  0.834 
  -0.056  0.730 
  -0.032  0.564 curveto
  
   0.055  0.355
   0.080  0.330
   0.250  0.250 curveto

   0.372  0.194  
   0.452  0.132 
   0.564  0.032 curveto 

   0.730  0.056  
   0.834  0.042 
   1.000  0.000 curveto 

   0.896  0.062 
   0.837  0.107 
   0.766  0.202 curveto 

   0.660  0.208 
   0.589  0.217 
   0.500  0.250 curveto 

   0.377  0.377 lineto 

   0.232  0.540 
   0.368  0.650 
   0.234  0.798 curveto 

   0.163  0.893 
   0.104  0.938 
   0.000  1.000 curveto 

   0.007 setlinewidth
   1 setlinejoin
   stroke 

} def


%%% TODO: should read primary and secondary color from stack.
% Consumes: 
%  - primary-color [ r g b ] 
%  - secondary-color [ r g b ]
/draw-efish {
   newpath 

   % pc sc 

   0.007 setlinewidth
   1 setlinejoin

   % FISH BODY

   0.000  0.000 moveto 

  -0.250  0.250 lineto 

  -0.194  0.372 
  -0.132  0.452 
  -0.032  0.564 curveto 

  -0.056  0.730 
  -0.042  0.834 
   0.000  1.000 curveto 

   0.104  0.938 
   0.163  0.893 
   0.234  0.798 curveto 

   0.340  0.792 
   0.411  0.783
   0.500  0.750 curveto 

   0.500  0.250 lineto 

   0.589  0.217 
   0.660  0.208 
   0.766  0.202 curveto 

   0.837  0.107
   0.896  0.062 
   1.000  0.000 curveto 

   0.834  0.042
   0.730  0.056 
   0.564  0.032 curveto

   0.452  0.132
   0.372  0.194 
   0.250  0.250 curveto 

   0.000  0.000 lineto 

   closepath 

   % pc sc 

   % Fish body uses primary color.

   exch                      % sc pc
   aload                     % sc r g b pc 
   5 1 roll                  % pc sc r g b 

   setrgbcolor % pc          % pc sc  

   fill

   % Done with fish body.

   % pc sc 

   % FISH DETAILS 

   newpath 

   % MAIN SPINE 

   0.025  0.900 moveto 

   0.140  0.500 
   0.350  0.120 
   0.840  0.070 curveto 

   % LEFT FIN STEM 

  -0.015  0.520 moveto 

   0.040  0.400 
   0.120  0.300 
   0.210  0.260 curveto 

   % RIGHT FIN STEM 

   0.240  0.770 moveto 

   0.340  0.600 
   0.320  0.350 
   0.475  0.270 curveto

   % RIGHT FIN BOTTOM DELIMITER 

   0.377  0.377 moveto 

   0.495  0.495 lineto 

   % TAIL FIN STEM 

   0.430  0.165 moveto 

   0.480  0.175
   0.490  0.220 
   0.490  0.230 curveto 

   % TAIL FIN BOTTOM LINE

   0.452 0.178 moveto 

   0.510 0.130 
   0.540 0.110 
   0.600 0.080 curveto 

   % TAIL FIN TOP LINE 

   0.482 0.215 moveto 

   0.520 0.200
   0.600 0.160
   0.740 0.150 curveto 

   % LEFT FIN TOP LINE 

  -0.170 0.237 moveto 

  -0.125 0.355
  -0.065 0.405 
   0.010 0.480 curveto 

   % LEFT FIN MIDDLE LINE 
  
  -0.110 0.175 moveto 

  -0.060 0.250 
  -0.030 0.300 
   0.080 0.365 curveto 

   % LEFT FIN BOTTOM LINE 

  -0.045 0.115 moveto 

   0.010 0.180  
   0.060 0.230 
   0.170 0.280 curveto  

   % RIGHT FIN TOP LINE 
 
   0.270 0.700 moveto 

   0.340 0.720 
   0.426 0.710 
   0.474 0.692 curveto 

   % RIGHT FIN MIDDLE LINE 

   0.310 0.570 moveto 
   
   0.400 0.622 
   0.435 0.618 
   0.474 0.615 curveto  

   % RIGHT FIN BOTTOM LINE 

   0.350 0.435 moveto 

   0.400 0.505  
   0.422 0.520 
   0.474 0.538 curveto

   % Fish details use secondary color.

   % pc sc 

   aload                      % pc r g b sc 
   4 1 roll                   % pc sc r g b
   
   setrgbcolor % sc           % pc sc  

   stroke 

   % Done with fish details.


   % THE EYES

   % Outer eyes:
   % Use secondary color for outer eyes fill unless primary color is white.
   % Always stroke outer eyes with secondary color.
   
   % Inner eyes:
   % Use primary color for inner eyes fill unless primary color is white.

   % Is the primary color white?
   % Add r g b values, the value should be 3 for white.

   % pc sc 

   exch                      % sc pc 
   aload                     % sc r g b pc
   5 1 roll                  % pc sc r g b

   add add 3 eq              % pc sc
   {
     exch                    % sc pc 
   } if                      % ic oc 

   % LEFT EYE

   newpath

   0.004  0.800 moveto 

  -0.012  0.770 
  -0.017  0.685 
  -0.008  0.592 curveto 

   0.010  0.617 
   0.045  0.660 
   0.074  0.685 curveto

   0.068  0.696 
   0.040  0.772 
   0.004  0.800 curveto 

   closepath 

   gsave
   aload                     % ic r g b oc
   4 1 roll                  % ic oc r g b
   setrgbcolor % oc          % ic oc 
   fill 
   grestore 

   stroke 

   % RIGHT EYE

   newpath 

   0.095  0.870 moveto 

   0.090  0.830 
   0.095  0.775 
   0.115  0.715 curveto 

   0.140  0.740 
   0.165  0.760 
   0.205  0.782 curveto 

   0.200  0.790 
   0.160  0.840 
   0.095  0.870 curveto 

   closepath 

   gsave
   aload                     % ic r g b oc
   pop                       % ic r g b
   setrgbcolor % oc          % ic 
   fill 
   grestore 

   % outer eye stroke is always secondary color 

   stroke

   % INNER LEFT EYE

   % ic 

   aload pop                 % r g b

   setrgbcolor % ic          % (empty stack)

   newpath 

   0.018  0.720 moveto 

   0.010  0.700 
   0.005  0.685 
   0.008  0.618 curveto 

   0.010  0.622 
   0.035  0.652 
   0.057  0.674 curveto 

   0.053  0.684 
   0.038  0.708 
   0.018  0.720 curveto 

   closepath 

   fill

   % INNER RIGHT EYE 

   newpath 

   0.128  0.810 moveto 

   0.122  0.795 
   0.126  0.760 
   0.132  0.736 curveto 

   0.139  0.740
   0.154  0.756 
   0.185  0.774 curveto 

   0.174  0.783 
   0.150  0.805 
   0.128  0.810 curveto 

   closepath 

   fill

} def

%%% VECTOR PROCEDURES 

% [x y]
/vlength {
  aload pop      % x y
  dup mul        % x y*y
  exch           % y*y x
  dup mul        % y*y x*x
  add 
  sqrt 
} def 

% [x1 y1] [x2 y2]
/dotproduct {
  aload pop          % [x1 y1] x2 y2 
  3 -1 roll          % x2 y2 [x1 y1]
  aload pop          % x2 y2 x1 y1
  exch               % x2 y2 y1 x1 
  4 1 roll           % x1 x2 y2 y1
  mul                % x1 x2 y
  3 1 roll           % y x1 x2 
  mul                % y x 
  add                % dp
} def 

%% [x y] f -> [x' y'] where x' = x * f, y' = y * f 
/vscale {
  exch           % f [x y]
  aload pop      % f x y
  2 index        % f x y f 
  mul            % f x y', y' = y * f
  3 1 roll       % y' f x
  mul            % y' x', x' = f * x
  exch           % x' y'
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 + x2 y1 + y2
/vadd {
  aload pop      % [x1 y1] x2 y2
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2
  add            % y2 y1 x', x' = x1 + x2 
  3 1 roll       % x' y2 y1
  add            % x' y', y' = y2 + y1
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 - x2 y1 - y2
/vsub {
  aload pop      % [x1 y1] x2 y2 
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2 
  sub            % y2 y1 x', x' = x1 - x2
  3 1 roll       % x' y2 y1 
  exch           % x' y1 y2 
  sub            % x' y', y' = y1 - y2 
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x y] -> [x' y'] where x' = -x, y' = -y
/vneg {
  aload pop      % x y
  neg            % x -y
  exch           % -y x
  neg            % -y -x
  exch           % -x -y 
  2 array        % -x -y [. .]
  astore         % [-x -y] 
} def


%%% BOX PROCEDURES

%% (a + b, c, -b)
%% [ [xa ya] [xb yb] [xc yc] ]
/turn-box { 
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  4 -1 roll      % [xc yc] [xb yb] [xb yb] [xa ya]
  vadd           % [xc yc] [xb yb] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [xc yc] [xb yb]
  vneg           % [xa+xb ya+yb] [xc yc] [-xb -yb]
  3 array        % [xa+xb ya+yb] [xc yc] [-xb -yb] [. . .]
  astore         % [ [xa+xb ya+yb] [xc yc] [-xb -yb] ]
} def

%% (a + b, -b, c)
%% [ [xa ya] [xb yb] [xc yc] ]
/flip-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  vneg           % [xa ya] [xc yc] [xb yb] [-xb -yb]
  3 1 roll       % [xa ya] [-xb -yb] [xc yc] [xb yb] 
  4 -1 roll      % [-xb -yb] [xc yc] [xb yb] [xa ya]
  vadd           % [-xb -yb] [xc yc] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [-xb -yb] [xc yc]
  3 array        % [xa+xb ya+yb] [-xb -yb] [xc yc] [. . .]
  astore         % [ [xa+xb ya+yb] [-xb -yb] [xc yc] ]
} def

%% (a’, b’, c’) = (a + (b + c) / 2, (b + c) / 2, (c − b) / 2)
%% [ [xa ya] [xb yb] [xc yc] ]
/toss-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  2 copy         % [xa ya] [xb yb] [xc yc] [xb yb] [xc yc] 
  exch           % [xa ya] [xb yb] [xc yc] [xc yc] [xb yb]
  vsub           % [xa ya] [xb yb] [xc yc] [xc-xb yc-yb]
  0.5 vscale     % [xa ya] [xb yb] [xc yc] [(xc-xb)/2 (yc-yb)/2]
  4 1 roll       % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb yb] [xc yc]
  vadd           % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb+xc yb+yc]
  0.5 vscale     % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  dup            % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2] [(xb+xc)/2 (yb+yc)/2]
  4 1 roll       % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  vadd           % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa+(xb+xc)/2 ya+(yb+yc)/2]
  3 1 roll       % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2]
  3 array        % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [. . .]
  astore         % [ [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] ]
} def

/move-vert {       % bx f 
  exch             % f bx
  aload pop        % f a b c 
  dup              % f a b c c
  5 -1 roll        % a b c c f
  vscale           % a b c c'
  4 -1 roll        % b c c' a
  vadd             % b c a'
  3 1 roll         % a' b c 
  3 array astore   % [ a' b c ]
} def

/move-hori {       % bx f
  exch             % f bx
  aload pop        % f a b c
  exch             % f a c b 
  dup              % f a c b b 
  5 -1 roll        % a c b b f
  vscale           % a c b b'
  4 -1 roll        % c b b' a 
  vadd             % c b a
  3 1 roll         % a c b 
  exch             % a b c 
  3 array astore   % [a' b c ]
} def

/scale-vert {      % bx f 
  exch             % f bx 
  aload pop        % f a b c
  4 -1 roll        % a b c f
  vscale           % a b c'
  3 array astore   % [ a b c' ]  
} def 

/scale-hori {       % bx f 
  exch             % f bx 
  aload pop        % f a b c 
  exch             % f a c b 
  4 -1 roll        % a c b f 
  vscale           % a c b'
  exch             % a b' c 
  3 array astore   % [ a b' c ]
} def


%%% PICTURE PROCEDURES

% Consumes: a procedure that draws lines for a picture.
% Produces: a picture-procedure that consumes a box and draws a picture.
/create-picture {    % bx
  [ exch             % [ d 
    { 
      gsave
      exch           % d bx 
      aload pop      % d a b c 
      3 -1 roll      % d b c a
      aload pop      % d b c xa ya

      %(translate) == 
      %2 copy == == 

      translate      % d b c 
      aload          % d b c xc yc c
      vlength        % d b c xc yc cl
      4 1 roll       % d cl b xc yc 
      exch atan      % d cl b ac

      %(c-angle) == 
      %dup == 

      exch           % d cl ac b
      aload          % d cl ac xb yb b
      vlength        % d cl ac xb yb bl
      4 1 roll       % d cl bl ac xb yb
      exch atan      % d cl bl ac ab

      %(b-angle) == 
      %dup == 

      dup            % d cl bl ac ab ab 
      3 1 roll       % d cl bl ab ac ab
      sub            % d cl bl ab da

      %(delta-angle) ==
      %dup == 

      dup 180 ge { 360 sub } if 

      dup -180 le { 360 add } if

      %(delta-angle') ==
      %dup == 

      dup abs div    % d cl bl ab x    | x = 1 or -1
      dup neg        % d cl bl ab x -x
      1 add 90 mul   % d cl bl ab x g  | g = 0 or 180
      3 -1 roll      % d cl bl x g ab
      add            % d cl bl x ang

      %(rotate) ==
      %dup == 

      rotate         % d cl bl x
      mul            % d cl bl'
      exch           % d bl' cl

      %(scale) ==
      %2 copy == ==

      scale          % d
      exec           % 
      grestore       
    } /exec cvx 
  ] cvx 
} def 

%% picture -> picture
/turn {
  [                % p [
    exch           % [ p
    /turn-box cvx  % [ p turn-box 
    exch           % [ turn-box p 
    /exec cvx      % [ turn-box p exec
  ] cvx            % { turn-box p exec }
} def

/flip {
  [              % p [
  exch           % [ p
  /exec          % [ p /exec 
  cvx            % [ p exec 
  /flip-box      % [ p exec /flip-box 
  cvx            % [ p exec flip-box
  3 1 roll       % [ flip-box p exec
  ]              % [ flip-box p exec ]
  cvx            % { flip-box p exec }
} def

/toss {
  [              % p [
  exch           % [ p
  /exec          % [ p /exec 
  cvx            % [ p exec 
  /toss-box      % [ p exec /toss-box 
  cvx            % [ p exec toss-box
  3 1 roll       % [ toss-box p exec
  ]              % [ toss-box p exec ]
  cvx            % { toss-box p exec }
} def

% Consumes: p1 p2 m n 
% Produces: p  
/above-ratio {
  [                % box * p1 p2 m n [
    5 1 roll       % box [ p1 p2 m n
    {
      1 index      % box p1 p2 m n m 
      add          % box p1 p2 m t
      div          % box p1 p2 f
      dup          % box p1 p2 f f 
      1            % box p1 p2 f f 1
      exch         % box p1 p2 f 1 f 
      sub          % box p1 p2 f f'
      dup          % box p1 p2 f f' f'
      3 1 roll     % box p1 p2 f' f f'
      6 -1 roll    % p1 p2 f' f f' box 
      dup          % p1 p2 f' f f' box box 
      7 1 roll     % box p1 p2 f' f f' box
      exch         % box p1 p2 f' f box f'  
      move-vert    % box p1 p2 f' f box'    (box' = box f' mv)
      exch         % box p1 p2 f' box' f 
      scale-vert   % box p1 p2 f' box1
      4 -1 roll    % box p2 f' box1 p1
      exec         % box p2 f'
      exch         % box f' p2 
      3 1 roll     % p2 box f'
      scale-vert   % p2 box2 
      exch         % box2 p2 
      exec         %
    } /exec cvx 
  ] cvx
} def

/above {
  1 1 above-ratio
} def 

% Consumes: p1 p2 m n 
% Produces: p  
/beside-ratio {
  [                % box * p1 p2 m n [
    5 1 roll       % box [ p1 p2 m n
    {
      1 index      % box p1 p2 m n m 
      add          % box p1 p2 m t
      div          % box p1 p2 f
      dup          % box p1 p2 f f 
      1            % box p1 p2 f f 1
      exch         % box p1 p2 f 1 f 
      sub          % box p1 p2 f f'
      exch         % box p1 p2 f' f
      dup          % box p1 p2 f' f f
      6 -1 roll    % p1 p2 f' f f box
      dup          % p1 p2 f' f f box box 
      3 2 roll     % p1 p2 f' f box box f 
      scale-hori   % p1 p2 f' f box box1 
      6 -1 roll    % p2 f' f box box1 p1 
      exec         % p2 f' f box 
      exch         % p2 f' box f
      move-hori    % p2 f' box'
      exch         % p2 box' f'
      scale-hori   % p2 box2 
      exch         % box2 p2 
      exec 
    } /exec cvx 
  ] cvx
} def

/beside {
  1 1 beside-ratio 
} def 

/quartet {
  [                % box * nw ne sw se [
    5 1 roll       % box [ nw ne sw se
    {              % box nw ne sw se 
      beside       % box nw ne s 
      4 1 roll     % s box nw ne 
      beside       % s box n 
      3 -1 roll    % box n s 
      above        % box p 
      exec 
    } /exec cvx 
  ] cvx   
} def

% Consumes: w m e 
% Produces: p'
/row {
  [                    % box * w m e [
    4 1 roll           % box [ w m e
    {                  % box w m e 
      beside           % box w me 
      1 2 beside-ratio % box p'
      exec             % 
    } /exec cvx 
  ] cvx     
} def

% Consumes: n m s 
% Produces: p'
/column {
  [                    % box * n m s [
    4 1 roll           % box [ n m s
    {                  % box n m s 
      above            % box n ms  
      1 2 above-ratio  % box p'
      exec             % 
    } /exec cvx 
  ] cvx     
} def

/nonet {
  [                % box * nw nm ne mw mm me sw sm se [
    10 1 roll       % box [ nw nm ne mw mm me sw sm se
    {              % box nw nm ne mw mm me sw sm se
      row          % box nw nm ne mw mm me s 
      7 1 roll     % box s nw nm ne mw mm me
      row          % box s nw nm ne m
      5 1 roll     % box m s nw nm n 
      row          % box m s n 
      3 1 roll     % box n m s 
      column       % box p'
      exec 
    } /exec cvx 
  ] cvx   
} def

% Consumes: p1 p2 
% Produces: p  
/over {
  [                % box * p1 p2 [
    3 1 roll       % box [ p1 p2 
    {              % box p1 p2
      2 index      % box p1 p2 box 
      exch         % box p1 box p2 
      exec         % box p1 
      exec         %
    } /exec cvx
  ] cvx
} def

% Consumes: p 
% Produces: p' 
/ttile {
  [                  % box * p [
    exch             % box [ p
    {                % box p
      dup            % box p p 
      toss flip      % box p pn
      dup            % box p pn pn  
      turn turn turn % box p pn pe
      over over      % box p'
      exec
    } /exec cvx
  ] cvx
} def

% Consumes: p 
% Produces: p' 
/utile {
  [                  % box * p [
    exch             % box [ p
    {                % box p
      toss flip      % box pn
      dup turn       % box pn pw
      dup turn       % box pn pw ps 
      dup turn       % box pn pw ps pe 
      over over over % box p'
      exec           %
    } /exec cvx
  ] cvx
} def 

% Consumes: p n 
% Produces: p'
/side {
  [                  % box * p n [
    3 1 roll         % box [ p n
    {                % box p n
      dup            % box p n n
      0 le           % box p n, n <= 0
      {
        pop pop      % box 
        /blank load  % box blank
      } 
      {              % box p n, n > 1
        1 sub        % box p n-1
        1 index      % box p n-1 p
        exch         % box p p n-1 
        side         % box p s
        dup          % box p s s 
        3 -1 roll    % box s s p 
        ttile        % box s s t 
        dup          % box s s t t
        turn         % box s s t t' 
        exch         % box s s t' t 
        quartet      % box q
      } ifelse
      exec           %
    } /exec cvx
  ] cvx
} def 

% Consumes: p n 
% Produces: p'
/corner {
  [                  % box * p n [
    3 1 roll         % box [ p n
    {                % box p n
      dup            % box p n n
      0 le           % box p n, n <= 0
      {
        pop pop      % box 
        /blank load  % box blank
      } 
      {              % box p n, n > 1
        1 sub        % box p n-1
        1 index      % box p n-1 p
        exch         % box p p n-1 
        2 copy       % box p p n-1 p n-1
        corner       % box p p n-1 c 
        3 1 roll     % box p c p n-1
        side         % box p c s 
        dup turn     % box p c s s' 
        4 -1 roll    % box c s s' p 
        utile        % box c s s' u
        quartet      % box p'
      } ifelse
      exec           %
    } /exec cvx
  ] cvx
} def 

% Consumes: p k
% Produces: p' 
/square-limit {
  [                  % box * p k [
    3 1 roll         % box [ p k
    {                % box p k
      2 copy         % box p k p k
      1 index        % box p k p k p 
      utile          % box p k p k u 
      5 1 roll       % box u p k p k 
      side           % box u p k z
      3 1 roll       % box u z p k 
      corner         % box u z c 
      dup turn       % box u z nw sw 
      dup turn       % box u z nw sw se 
      dup turn       % box u z nw sw se ne
      3 1 roll       % box u z nw ne sw se 
      5 -1 roll      % box u nw ne sw se n
      dup turn       % box u nw ne sw se n w 
      dup turn       % box u nw ne sw se n w s
      dup turn       % box u nw ne sw se n w s e
      6 1 roll       % box u nw ne e sw se n w s 
      4 1 roll       % box u nw ne e sw s se n w
      6 1 roll       % box u nw ne w e sw s se n
      7 1 roll       % box u nw n ne w e sw s se 
      9 -1 roll      % box nw n ne w e sw s se u 
      5 1 roll       % box nw n ne w u e sw s se 
      nonet          % box p'
      exec           %
    } /exec cvx
  ] cvx
} def


%%% PICTURES

/blank { pop } def 

/f-picture { draw-f } create-picture def

/george-picture { draw-george } create-picture def

/fh-picture { draw-hfish } create-picture def 

%/fish-picture { [1 1 1] [0 0 0] draw-efish } create-picture def 
/fish-picture { [0.5 0.5 0.5] [1 1 1] draw-efish } create-picture def 
%/fish-picture { [0 0 0] [1 1 1] draw-efish } create-picture def 

%%% BOXES

/some-box [ [100 400] [400 0] [0 400] ] def

/big-box [ [50 200] [500 0] [0 500] ] def


% some-box /fh-picture load exec 

% some-box /fh-picture load utile /blank load dup 2 index quartet exec 

% some-box /fh-picture load 3 corner exec

% some-box /fh-picture load turn turn turn exec 

% big-box /fh-picture load 3 square-limit exec 

some-box /fish-picture load exec 

% some-box /fh-picture load dup dup dup dup dup dup dup dup nonet exec 

% some-box /f-picture load toss exec  

% some-box /f-picture load dup turn 3 2 above-ratio exec

% some-box /f-picture load dup flip dup dup flip quartet exec 

% some-box /george-picture load dup turn turn flip beside exec

% some-box /george-picture load dup turn turn flip 1 index turn turn 2 index flip quartet exec
