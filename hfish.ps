%!PS-Adobe-2.0 EPSF-2.0
%%Title: Henderson's Square Limit - a postscript on functional geometry
%%Creator: Einar W. Høst 
%%Pages: 1
%%EndComments
%%BeginProlog
%%EndProlog

%%Page: 1 1

%%% DRAWING PROCEDURES

/draw-f {
  newpath
  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.45 lineto
  0.60 0.45 lineto
  0.60 0.55 lineto
  0.40 0.55 lineto
  0.40 0.70 lineto
  0.70 0.70 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-h {
  newpath
  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.45 lineto
  0.60 0.45 lineto
  0.60 0.20 lineto
  0.70 0.20 lineto
  0.70 0.80 lineto
  0.60 0.80 lineto
  0.60 0.55 lineto
  0.40 0.55 lineto
  0.40 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-e {
  newpath
  0.30 0.20 moveto 
  0.70 0.20 lineto
  0.70 0.30 lineto
  0.40 0.30 lineto
  0.40 0.45 lineto
  0.60 0.45 lineto
  0.60 0.55 lineto
  0.40 0.55 lineto
  0.40 0.70 lineto
  0.70 0.70 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-n {
  newpath
  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.60 lineto
  0.60 0.20 lineto
  0.70 0.20 lineto
  0.70 0.80 lineto
  0.60 0.80 lineto
  0.60 0.40 lineto
  0.40 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-d {
  newpath
  0.30 0.20 moveto 
  0.55 0.20 lineto
  0.70 0.35 lineto
  0.70 0.65 lineto
  0.55 0.80 lineto
  0.30 0.80 lineto
  0.30 0.20 lineto

  0.40 0.30 moveto 
  0.52 0.30 lineto
  0.60 0.38 lineto
  0.60 0.62 lineto
  0.52 0.70 lineto
  0.40 0.70 lineto
  closepath

  0.01 setlinewidth
  stroke 
} def

/draw-r {
  newpath

  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.45 lineto
  0.45 0.45 lineto
  0.60 0.20 lineto
  0.70 0.20 lineto
  0.55 0.45 lineto
  0.70 0.45 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  0.30 0.20 lineto 

  0.40 0.55 moveto 
  0.60 0.55 lineto
  0.60 0.70 lineto
  0.40 0.70 lineto
  0.40 0.55 lineto

  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-s {
  newpath
  0.30 0.20 moveto 
  0.70 0.20 lineto
  0.70 0.55 lineto
  0.40 0.55 lineto
  0.40 0.70 lineto
  0.70 0.70 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  0.30 0.45 lineto
  0.60 0.45 lineto
  0.60 0.30 lineto
  0.30 0.30 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-o {
  newpath

  0.30 0.20 moveto 
  0.70 0.20 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  0.30 0.20 lineto

  0.40 0.30 moveto 
  0.60 0.30 lineto
  0.60 0.70 lineto
  0.40 0.70 lineto
  0.40 0.30 lineto

  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-george {
  newpath

  0.00 0.55 moveto
  0.15 0.45 lineto 
  0.30 0.55 lineto
  0.40 0.50 lineto 
  0.20 0.00 lineto 

  0.00 0.80 moveto 
  0.15 0.60 lineto
  0.30 0.65 lineto
  0.40 0.65 lineto
  0.35 0.80 lineto
  0.40 1.00 lineto

  0.60 1.00 moveto 
  0.65 0.80 lineto 
  0.60 0.65 lineto 
  0.80 0.65 lineto
  1.00 0.45 lineto

  1.00 0.20 moveto 
  0.60 0.50 lineto 
  0.80 0.00 lineto

  0.40 0.00 moveto 
  0.50 0.30 lineto 
  0.60 0.00 lineto

  0.01 setlinewidth
  stroke 
} def 

/draw-hfish {
   newpath 

  % FISH SPINE 
 
   0.116  0.702 moveto 
   
   0.260  0.295 
   0.330  0.258  
   0.815  0.078 curveto 

  % LEFT FIN OUTLINE 

  -0.032  0.564 moveto 

  -0.132  0.452 
  -0.194  0.372 
  -0.250  0.250 curveto 

   0.000  0.000 lineto 

   0.250  0.250 lineto 

  % LEFT FIN DETAILS 

  -0.170  0.237 moveto

  -0.125  0.355 
  -0.065  0.405 
   0.002  0.436 curveto 

  -0.121  0.188 moveto 

  -0.060  0.300
  -0.030  0.330 
   0.040  0.375 curveto 

  -0.058  0.125 moveto 

  -0.010  0.240 
   0.030  0.280 
   0.100  0.321 curveto  
  
  -0.022  0.063 moveto 

   0.060 0.200 
   0.100 0.240 
   0.160 0.282 curveto 

  % RIGHT FIN OUTLINE

   0.234  0.798 moveto 
   
   0.340  0.792
   0.411  0.783
   0.500  0.750 curveto 

   0.500  0.500 lineto 

   0.377  0.377 lineto

  % RIGHT FIN DETAILS

   0.315  0.710 moveto 
  
   0.378  0.732 
   0.426  0.726
   0.487  0.692 curveto

   0.340  0.605 moveto 

   0.400  0.642 
   0.435  0.647 
   0.489  0.626 curveto 

   0.348  0.502 moveto 
   
   0.400  0.564 
   0.422  0.568 
   0.489  0.563 curveto 

   0.451  0.418 moveto 

   0.465  0.400
   0.480  0.385
   0.490  0.381 curveto 

   0.421  0.388 moveto 

   0.440  0.350 
   0.455  0.335 
   0.492  0.325 curveto

  % LEFT EYE

   0.053  0.658 moveto 
   
   0.042  0.710
   0.042  0.760
   0.053  0.819 curveto 

   0.085  0.812
   0.092  0.752
   0.098  0.700 curveto 

   0.085  0.687
   0.075  0.677
   0.053  0.658 curveto 

  % RIGHT EYE

   0.130  0.718 moveto 
   
   0.150  0.730
   0.175  0.745
   0.187  0.752 curveto 

   0.172  0.780 
   0.150  0.805 
   0.112  0.845 curveto 

   0.110  0.810 
   0.110  0.795 
   0.130  0.718 curveto  
    
  % MAIN FISH BODY OUTLINE

   0.000  1.000 moveto 
  -0.042  0.834 
  -0.056  0.730 
  -0.032  0.564 curveto
  
   0.055  0.355
   0.080  0.330
   0.250  0.250 curveto

   0.372  0.194  
   0.452  0.132 
   0.564  0.032 curveto 

   0.730  0.056  
   0.834  0.042 
   1.000  0.000 curveto 

   0.896  0.062 
   0.837  0.107 
   0.766  0.202 curveto 

   0.660  0.208 
   0.589  0.217 
   0.500  0.250 curveto 

   0.377  0.377 lineto 

   0.232  0.540 
   0.368  0.650 
   0.234  0.798 curveto 

   0.163  0.893 
   0.104  0.938 
   0.000  1.000 curveto 

   0.007 setlinewidth
   1 setlinejoin
   stroke 

} def

%%% A postscript about recursive fish.

%%% VECTOR PROCEDURES 

% [x y]
/vlength {
  aload pop      % x y
  dup mul        % x y*y
  exch           % y*y x
  dup mul        % y*y x*x
  add 
  sqrt 
} def 

% [x1 y1] [x2 y2]
/dotproduct {
  aload pop          % [x1 y1] x2 y2 
  3 -1 roll          % x2 y2 [x1 y1]
  aload pop          % x2 y2 x1 y1
  exch               % x2 y2 y1 x1 
  4 1 roll           % x1 x2 y2 y1
  mul                % x1 x2 y
  3 1 roll           % y x1 x2 
  mul                % y x 
  add                % dp
} def 

%% [x y] f -> [x' y'] where x' = x * f, y' = y * f 
/vscale {
  exch           % f [x y]
  aload pop      % f x y
  2 index        % f x y f 
  mul            % f x y', y' = y * f
  3 1 roll       % y' f x
  mul            % y' x', x' = f * x
  exch           % x' y'
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 + x2 y1 + y2
/vadd {
  aload pop      % [x1 y1] x2 y2
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2
  add            % y2 y1 x', x' = x1 + x2 
  3 1 roll       % x' y2 y1
  add            % x' y', y' = y2 + y1
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 - x2 y1 - y2
/vsub {
  aload pop      % [x1 y1] x2 y2 
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2 
  sub            % y2 y1 x', x' = x1 - x2
  3 1 roll       % x' y2 y1 
  exch           % x' y1 y2 
  sub            % x' y', y' = y1 - y2 
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x y] -> [x' y'] where x' = -x, y' = -y
/vneg {
  aload pop      % x y
  neg            % x -y
  exch           % -y x
  neg            % -y -x
  exch           % -x -y 
  2 array        % -x -y [. .]
  astore         % [-x -y] 
} def


%%% BOX PROCEDURES

%% (a, b, c) -> (a + b, c, -b)
%% [ [xa ya] [xb yb] [xc yc] ]
/turn-box { 
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  4 -1 roll      % [xc yc] [xb yb] [xb yb] [xa ya]
  vadd           % [xc yc] [xb yb] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [xc yc] [xb yb]
  vneg           % [xa+xb ya+yb] [xc yc] [-xb -yb]
  3 array        % [xa+xb ya+yb] [xc yc] [-xb -yb] [. . .]
  astore         % [ [xa+xb ya+yb] [xc yc] [-xb -yb] ]
} def

%% (a, b, c) -> (a + b, -b, c)
%% [ [xa ya] [xb yb] [xc yc] ]
/flip-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  vneg           % [xa ya] [xc yc] [xb yb] [-xb -yb]
  3 1 roll       % [xa ya] [-xb -yb] [xc yc] [xb yb] 
  4 -1 roll      % [-xb -yb] [xc yc] [xb yb] [xa ya]
  vadd           % [-xb -yb] [xc yc] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [-xb -yb] [xc yc]
  3 array        % [xa+xb ya+yb] [-xb -yb] [xc yc] [. . .]
  astore         % [ [xa+xb ya+yb] [-xb -yb] [xc yc] ]
} def

%% (a, b, c) -> (a + (b + c) / 2, (b + c) / 2, (c − b) / 2)
%% [ [xa ya] [xb yb] [xc yc] ]
/toss-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  2 copy         % [xa ya] [xb yb] [xc yc] [xb yb] [xc yc] 
  exch           % [xa ya] [xb yb] [xc yc] [xc yc] [xb yb]
  vsub           % [xa ya] [xb yb] [xc yc] [xc-xb yc-yb]
  0.5 vscale     % [xa ya] [xb yb] [xc yc] [(xc-xb)/2 (yc-yb)/2]
  4 1 roll       % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb yb] [xc yc]
  vadd           % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb+xc yb+yc]
  0.5 vscale     % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  dup            % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2] [(xb+xc)/2 (yb+yc)/2]
  4 1 roll       % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  vadd           % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa+(xb+xc)/2 ya+(yb+yc)/2]
  3 1 roll       % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2]
  3 array        % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [. . .]
  astore         % [ [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] ]
} def

/move-vert {       % bx f 
  exch             % f bx
  aload pop        % f a b c 
  dup              % f a b c c
  5 -1 roll        % a b c c f
  vscale           % a b c c'
  4 -1 roll        % b c c' a
  vadd             % b c a'
  3 1 roll         % a' b c 
  3 array astore   % [ a' b c ]
} def

/move-hori {       % bx f
  exch             % f bx
  aload pop        % f a b c
  exch             % f a c b 
  dup              % f a c b b 
  5 -1 roll        % a c b b f
  vscale           % a c b b'
  4 -1 roll        % c b b' a 
  vadd             % c b a
  3 1 roll         % a c b 
  exch             % a b c 
  3 array astore   % [a' b c ]
} def

/scale-vert {      % bx f 
  exch             % f bx 
  aload pop        % f a b c
  4 -1 roll        % a b c f
  vscale           % a b c'
  3 array astore   % [ a b c' ]  
} def 

/scale-hori {       % bx f 
  exch             % f bx 
  aload pop        % f a b c 
  exch             % f a c b 
  4 -1 roll        % a c b f 
  vscale           % a c b'
  exch             % a b' c 
  3 array astore   % [ a b' c ]
} def


%%% PICTURE PROCEDURES

% Consumes: a procedure that draws lines for a picture.
% Produces: a picture-procedure that consumes a box and draws a picture.
/create-picture {    % bx
  [ exch             % [ d 
    { 
      gsave
      exch           % d bx 
      aload pop      % d a b c 
      3 -1 roll      % d b c a
      aload pop      % d b c xa ya

      translate      % d b c 

      aload          % d b c xc yc c
      vlength        % d b c xc yc cl     | cl = length of c
      4 1 roll       % d cl b xc yc 
      exch atan      % d cl b ac          | ac = c-angle 

      exch           % d cl ac b
      aload          % d cl ac xb yb b
      vlength        % d cl ac xb yb bl   | bl = length of b
      4 1 roll       % d cl bl ac xb yb
      exch atan      % d cl bl ac ab      | ab = b-angle

      dup            % d cl bl ac ab ab 
      3 1 roll       % d cl bl ab ac ab
      sub            % d cl bl ab da      | da = delta-angle (ac - ab)

      dup 180 ge { 360 sub } if 
      dup -180 le { 360 add } if

      dup abs div    % d cl bl ab x    | x = 1 or -1
      dup neg        % d cl bl ab x -x
      1 add 90 mul   % d cl bl ab x g  | g = 0 or 180
      3 -1 roll      % d cl bl x g ab
      add            % d cl bl x ang

      rotate         % d cl bl x

      mul            % d cl bl'
      exch           % d bl' cl

      scale          % d
      exec           % 
      grestore       
    } /exec cvx 
  ] cvx 
} def 

%% picture -> picture
/turn {
  [                 % p [
    exch            % [ p
    /turn-box cvx   % [ p turn-box 
    exch            % [ turn-box p 
    /exec cvx       % [ turn-box p exec
  ] cvx             % { turn-box p exec }
} def

%% picture -> picture
/flip {
  [                % p [
    exch           % [ p
    /flip-box cvx  % [ p flip-box
    exch           % [ flip-box p 
    /exec cvx      % [ flip-box p exec 
  ] cvx            % { flip-box p exec }
} def

%% picture -> picture
/toss {
  [                % p [
    exch           % [ p
    /toss-box cvx  % [ p toss-box
    exch           % [ toss-box p 
    /exec cvx      % [ toss-box p exec 
  ] cvx            % { toss-box p exec }
} def

% Consumes: p1 p2 m n 
% Produces: p  
/above-ratio {
  [                % box * p1 p2 m n [
    5 1 roll       % box [ p1 p2 m n
    {
      1 index      % box p1 p2 m n m 
      add          % box p1 p2 m t
      div          % box p1 p2 f
      dup          % box p1 p2 f f 
      1            % box p1 p2 f f 1
      exch         % box p1 p2 f 1 f 
      sub          % box p1 p2 f f'
      dup          % box p1 p2 f f' f'
      3 1 roll     % box p1 p2 f' f f'
      6 -1 roll    % p1 p2 f' f f' box 
      dup          % p1 p2 f' f f' box box 
      7 1 roll     % box p1 p2 f' f f' box
      exch         % box p1 p2 f' f box f'  
      move-vert    % box p1 p2 f' f box'    (box' = box f' mv)
      exch         % box p1 p2 f' box' f 
      scale-vert   % box p1 p2 f' box1
      4 -1 roll    % box p2 f' box1 p1
      exec         % box p2 f'
      exch         % box f' p2 
      3 1 roll     % p2 box f'
      scale-vert   % p2 box2 
      exch         % box2 p2 
      exec         %
    } /exec cvx 
  ] cvx
} def

/above {
  1 1 above-ratio
} def 

% Consumes: p1 p2 m n 
% Produces: p  
/beside-ratio {
  [                % box * p1 p2 m n [
    5 1 roll       % box [ p1 p2 m n
    {
      1 index      % box p1 p2 m n m 
      add          % box p1 p2 m t
      div          % box p1 p2 f
      dup          % box p1 p2 f f 
      1            % box p1 p2 f f 1
      exch         % box p1 p2 f 1 f 
      sub          % box p1 p2 f f'
      exch         % box p1 p2 f' f
      dup          % box p1 p2 f' f f
      6 -1 roll    % p1 p2 f' f f box
      dup          % p1 p2 f' f f box box 
      3 2 roll     % p1 p2 f' f box box f 
      scale-hori   % p1 p2 f' f box box1 
      6 -1 roll    % p2 f' f box box1 p1 
      exec         % p2 f' f box 
      exch         % p2 f' box f
      move-hori    % p2 f' box'
      exch         % p2 box' f'
      scale-hori   % p2 box2 
      exch         % box2 p2 
      exec 
    } /exec cvx 
  ] cvx
} def

/beside {
  1 1 beside-ratio 
} def 

/quartet {              % nw ne sw se
  beside                % nw ne s 
  3 1 roll              % s nw ne 
  beside                % s n 
  exch                  % n s
  above                 % p 
} def

% Consumes: w m e 
% Produces: p'
/row {                  % w m e
  beside                % w m 
  1 2 beside-ratio      % p'
} def

% Consumes: n m s 
% Produces: p'
/column {               % n m s 
  above                 % n ms
  1 2 above-ratio       % p'
} def

% Consumes: nw nm ne mw mm me sw sm se 
% Produces: p'
/nonet {
  row          % nw nm ne mw mm me s 
  7 1 roll     % s nw nm ne mw mm me
  row          % s nw nm ne m
  5 1 roll     % m s nw nm n 
  row          % m s n 
  3 1 roll     % n m s 
  column       % p'   
} def

% Consumes: p1 p2 
% Produces: p  
/over {
  [                % box * p1 p2 [
    3 1 roll       % box [ p1 p2 
    {              % box p1 p2
      2 index      % box p1 p2 box 
      exch         % box p1 box p2 
      exec         % box p1 
      exec         %
    } /exec cvx
  ] cvx
} def

% Consumes: p 
% Produces: p' 
/ttile {
  dup                   % p p 
  toss flip             % p pn
  dup                   % p pn pn  
  turn turn turn        % p pn pe
  over over             % p'
} def

% Consumes: p 
% Produces: p' 
/utile {
  toss flip                  % pn
  dup turn                   % pn pw
  dup turn                   % pn pw ps 
  dup turn                   % pn pw ps pe 
  over over over             % p'
} def 

% Consumes: p n 
% Produces: p'
/side {
  dup            % p n n
  0 le           % p n, n <= 0
  {
    pop pop      % 
    /blank load  % blank
  } 
  {              % p n, n > 1
    1 sub        % p n-1
    1 index      % p n-1 p
    exch         % p p n-1 
    side         % p s
    dup          % p s s 
    3 -1 roll    % s s p 
    ttile        % s s t 
    dup          % s s t t
    turn         % s s t t' 
    exch         % s s t' t 
    quartet      % q
  } ifelse
} def 

% Consumes: p n 
% Produces: p'
/corner {
  dup            % p n n
  0 le           % p n, n <= 0
  {
    pop pop      % 
    /blank load  % blank
  } 
  {              % p n, n > 1
    1 sub        % p n-1
    1 index      % p n-1 p
    exch         % p p n-1 
    2 copy       % p p n-1 p n-1
    corner       % p p n-1 c 
    3 1 roll     % p c p n-1
    side         % p c s 
    dup turn     % p c s s' 
    4 -1 roll    % c s s' p 
    utile        % c s s' u
    quartet      % p'
  } ifelse
} def 

% Consumes: p k
% Produces: p' 
/square-limit {
  2 copy         % p k p k
  1 index        % p k p k p 
  utile          % p k p k u 
  5 1 roll       % u p k p k 
  side           % u p k z
  3 1 roll       % u z p k 
  corner         % u z c 
  dup turn       % u z nw sw 
  dup turn       % u z nw sw se 
  dup turn       % u z nw sw se ne
  3 1 roll       % u z nw ne sw se 
  5 -1 roll      % u nw ne sw se n
  dup turn       % u nw ne sw se n w 
  dup turn       % u nw ne sw se n w s
  dup turn       % u nw ne sw se n w s e
  6 1 roll       % u nw ne e sw se n w s 
  4 1 roll       % u nw ne e sw s se n w
  6 1 roll       % u nw ne w e sw s se n
  7 1 roll       % u nw n ne w e sw s se 
  9 -1 roll      % nw n ne w e sw s se u 
  5 1 roll       % nw n ne w u e sw s se 
  nonet          % p'
} def

%%% PICTURES

/blank { pop } def 

/f /draw-f load create-picture def 
/h /draw-h load create-picture def 
/e /draw-e load create-picture def 
/n /draw-n load create-picture def 
/d /draw-d load create-picture def 
/r /draw-r load create-picture def 
/s /draw-s load create-picture def 
/o /draw-o load create-picture def 

/zoom {       % ?
  /h load     % ? h 
  /e load     % ? h e 
  /n load     % ? h e n 
  /d load     % ? h e n d 
  5 -1 roll   % h e n d ? 
  /r load     % h e n d ? r 
  /s load     % h e n d ? r s 
  /o load     % h e n d ? r s o
  /n load     % h e n d ? r s o n
  nonet 
} def

/g /draw-george load create-picture def

/fish /draw-hfish load create-picture def 

%%% BOXES

/small-box [ [100 200] [200 0] [0 200] ] def

/some-box [ [100 400] [400 0] [0 400] ] def

/fish-box [ [100 400] [300 0] [0 300] ] def

/skew-box [ [100 400] [200 20] [-30 400] ] def

/big-box [ [50 200] [500 0] [0 500] ] def

big-box /fish load 4 square-limit exec 

% gswin64 -sDEVICE=pdfwrite -o hfish-4.pdf hfish.ps

%%Trailer
%%Pages:      1
%%EOF