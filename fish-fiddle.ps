%! 

%%% A postscript about recursive fish.

%%% DRAWING PROCEDURES

/draw-f {
  newpath
  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.45 lineto
  0.60 0.45 lineto
  0.60 0.55 lineto
  0.40 0.55 lineto
  0.40 0.70 lineto
  0.70 0.70 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

/draw-george {
  newpath

  0.00 0.55 moveto
  0.15 0.45 lineto 
  0.30 0.55 lineto
  0.40 0.50 lineto 
  0.20 0.00 lineto 

  0.00 0.80 moveto 
  0.15 0.60 lineto
  0.30 0.65 lineto
  0.40 0.65 lineto
  0.35 0.80 lineto
  0.40 1.00 lineto

  0.60 1.00 moveto 
  0.65 0.80 lineto 
  0.60 0.65 lineto 
  0.80 0.65 lineto
  1.00 0.45 lineto

  1.00 0.20 moveto 
  0.60 0.50 lineto 
  0.80 0.00 lineto

  0.40 0.00 moveto 
  0.50 0.30 lineto 
  0.60 0.00 lineto

  0.01 setlinewidth
  stroke 
} def 

/draw-hfish {
   newpath 

  % FISH SPINE 
 
   0.116  0.702 moveto 
   
   0.260  0.295 
   0.330  0.258  
   0.815  0.078 curveto 

  % LEFT FIN OUTLINE 

  -0.032  0.564 moveto 

  -0.132  0.452 
  -0.194  0.372 
  -0.250  0.250 curveto 

   0.000  0.000 lineto 

   0.250  0.250 lineto 

  % LEFT FIN DETAILS 

  -0.170  0.237 moveto

  -0.125  0.355 
  -0.065  0.405 
   0.002  0.436 curveto 

  -0.121  0.188 moveto 

  -0.060  0.300
  -0.030  0.330 
   0.040  0.375 curveto 

  -0.058  0.125 moveto 

  -0.010  0.240 
   0.030  0.280 
   0.100  0.321 curveto  
  
  -0.022  0.063 moveto 

   0.060 0.200 
   0.100 0.240 
   0.160 0.282 curveto 

  % RIGHT FIN OUTLINE

   0.234  0.798 moveto 
   
   0.340  0.792
   0.411  0.783
   0.500  0.750 curveto 

   0.500  0.500 lineto 

   0.377  0.377 lineto

  % RIGHT FIN DETAILS

   0.315  0.710 moveto 
  
   0.378  0.732 
   0.426  0.726
   0.487  0.692 curveto

   0.340  0.605 moveto 

   0.400  0.642 
   0.435  0.647 
   0.489  0.626 curveto 

   0.348  0.502 moveto 
   
   0.400  0.564 
   0.422  0.568 
   0.489  0.563 curveto 

   0.451  0.418 moveto 

   0.465  0.400
   0.480  0.385
   0.490  0.381 curveto 

   0.421  0.388 moveto 

   0.440  0.350 
   0.455  0.335 
   0.492  0.325 curveto

  % LEFT EYE

   0.053  0.658 moveto 
   
   0.042  0.710
   0.042  0.760
   0.053  0.819 curveto 

   0.085  0.812
   0.092  0.752
   0.098  0.700 curveto 

   0.085  0.687
   0.075  0.677
   0.053  0.658 curveto 

  % RIGHT EYE

   0.130  0.718 moveto 
   
   0.150  0.730
   0.175  0.745
   0.187  0.752 curveto 

   0.172  0.780 
   0.150  0.805 
   0.112  0.845 curveto 

   0.110  0.810 
   0.110  0.795 
   0.130  0.718 curveto  
    
  % MAIN FISH BODY OUTLINE

   0.000  1.000 moveto 
  -0.042  0.834 
  -0.056  0.730 
  -0.032  0.564 curveto
  
   0.055  0.355
   0.080  0.330
   0.250  0.250 curveto

   0.372  0.194  
   0.452  0.132 
   0.564  0.032 curveto 

   0.730  0.056  
   0.834  0.042 
   1.000  0.000 curveto 

   0.896  0.062 
   0.837  0.107 
   0.766  0.202 curveto 

   0.660  0.208 
   0.589  0.217 
   0.500  0.250 curveto 

   0.377  0.377 lineto 

   0.232  0.540 
   0.368  0.650 
   0.234  0.798 curveto 

   0.163  0.893 
   0.104  0.938 
   0.000  1.000 curveto 

   0.007 setlinewidth
   1 setlinejoin
   stroke 

} def


%%% VECTOR PROCEDURES 

% [x y]
/vlength {
  aload pop      % x y
  dup mul        % x y*y
  exch           % y*y x
  dup mul        % y*y x*x
  add 
  sqrt 
} def 

% [x1 y1] [x2 y2]
/dotproduct {
  aload pop          % [x1 y1] x2 y2 
  3 -1 roll          % x2 y2 [x1 y1]
  aload pop          % x2 y2 x1 y1
  exch               % x2 y2 y1 x1 
  4 1 roll           % x1 x2 y2 y1
  mul                % x1 x2 y
  3 1 roll           % y x1 x2 
  mul                % y x 
  add                % dp
} def 

%% [x y] f -> [x' y'] where x' = x * f, y' = y * f 
/vscale {
  exch           % f [x y]
  aload pop      % f x y
  2 index        % f x y f 
  mul            % f x y', y' = y * f
  3 1 roll       % y' f x
  mul            % y' x', x' = f * x
  exch           % x' y'
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 + x2 y1 + y2
/vadd {
  aload pop      % [x1 y1] x2 y2
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2
  add            % y2 y1 x', x' = x1 + x2 
  3 1 roll       % x' y2 y1
  add            % x' y', y' = y2 + y1
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 - x2 y1 - y2
/vsub {
  aload pop      % [x1 y1] x2 y2 
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2 
  sub            % y2 y1 x', x' = x1 - x2
  3 1 roll       % x' y2 y1 
  exch           % x' y1 y2 
  sub            % x' y', y' = y1 - y2 
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x y] -> [x' y'] where x' = -x, y' = -y
/vneg {
  aload pop      % x y
  neg            % x -y
  exch           % -y x
  neg            % -y -x
  exch           % -x -y 
  2 array        % -x -y [. .]
  astore         % [-x -y] 
} def


%%% BOX PROCEDURES

%% (a, b, c) -> (a + b, c, -b)
%% [ [xa ya] [xb yb] [xc yc] ]
/turn-box { 
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  4 -1 roll      % [xc yc] [xb yb] [xb yb] [xa ya]
  vadd           % [xc yc] [xb yb] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [xc yc] [xb yb]
  vneg           % [xa+xb ya+yb] [xc yc] [-xb -yb]
  3 array        % [xa+xb ya+yb] [xc yc] [-xb -yb] [. . .]
  astore         % [ [xa+xb ya+yb] [xc yc] [-xb -yb] ]
} def

%% (a, b, c) -> (a + b, -b, c)
%% [ [xa ya] [xb yb] [xc yc] ]
/flip-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  vneg           % [xa ya] [xc yc] [xb yb] [-xb -yb]
  3 1 roll       % [xa ya] [-xb -yb] [xc yc] [xb yb] 
  4 -1 roll      % [-xb -yb] [xc yc] [xb yb] [xa ya]
  vadd           % [-xb -yb] [xc yc] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [-xb -yb] [xc yc]
  3 array        % [xa+xb ya+yb] [-xb -yb] [xc yc] [. . .]
  astore         % [ [xa+xb ya+yb] [-xb -yb] [xc yc] ]
} def

%% (a, b, c) -> (a + (b + c) / 2, (b + c) / 2, (c âˆ’ b) / 2)
%% [ [xa ya] [xb yb] [xc yc] ]
/toss-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  2 copy         % [xa ya] [xb yb] [xc yc] [xb yb] [xc yc] 
  exch           % [xa ya] [xb yb] [xc yc] [xc yc] [xb yb]
  vsub           % [xa ya] [xb yb] [xc yc] [xc-xb yc-yb]
  0.5 vscale     % [xa ya] [xb yb] [xc yc] [(xc-xb)/2 (yc-yb)/2]
  4 1 roll       % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb yb] [xc yc]
  vadd           % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb+xc yb+yc]
  0.5 vscale     % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  dup            % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2] [(xb+xc)/2 (yb+yc)/2]
  4 1 roll       % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  vadd           % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa+(xb+xc)/2 ya+(yb+yc)/2]
  3 1 roll       % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2]
  3 array        % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [. . .]
  astore         % [ [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] ]
} def

/move-vert {       % bx f 
  exch             % f bx
  aload pop        % f a b c 
  dup              % f a b c c
  5 -1 roll        % a b c c f
  vscale           % a b c c'
  4 -1 roll        % b c c' a
  vadd             % b c a'
  3 1 roll         % a' b c 
  3 array astore   % [ a' b c ]
} def

/move-hori {       % bx f
  exch             % f bx
  aload pop        % f a b c
  exch             % f a c b 
  dup              % f a c b b 
  5 -1 roll        % a c b b f
  vscale           % a c b b'
  4 -1 roll        % c b b' a 
  vadd             % c b a
  3 1 roll         % a c b 
  exch             % a b c 
  3 array astore   % [a' b c ]
} def

/scale-vert {      % bx f 
  exch             % f bx 
  aload pop        % f a b c
  4 -1 roll        % a b c f
  vscale           % a b c'
  3 array astore   % [ a b c' ]  
} def 

/scale-hori {       % bx f 
  exch             % f bx 
  aload pop        % f a b c 
  exch             % f a c b 
  4 -1 roll        % a c b f 
  vscale           % a c b'
  exch             % a b' c 
  3 array astore   % [ a b' c ]
} def


%%% PICTURE PROCEDURES

% Consumes: a procedure that draws lines for a picture.
% Produces: a picture-procedure that consumes a box and draws a picture.
/create-picture {    % bx
  [ exch             % [ d 
    { 
      gsave
      exch           % d bx 
      aload pop      % d a b c 
      3 -1 roll      % d b c a
      aload pop      % d b c xa ya

      translate      % d b c 

      aload          % d b c xc yc c
      vlength        % d b c xc yc cl     | cl = length of c
      4 1 roll       % d cl b xc yc 
      exch atan      % d cl b ac          | ac = c-angle 

      exch           % d cl ac b
      aload          % d cl ac xb yb b
      vlength        % d cl ac xb yb bl   | bl = length of b
      4 1 roll       % d cl bl ac xb yb
      exch atan      % d cl bl ac ab      | ab = b-angle

      dup            % d cl bl ac ab ab 
      3 1 roll       % d cl bl ab ac ab
      sub            % d cl bl ab da      | da = delta-angle (ac - ab)

      dup 180 ge { 360 sub } if 
      dup -180 le { 360 add } if

      dup abs div    % d cl bl ab x    | x = 1 or -1
      dup neg        % d cl bl ab x -x
      1 add 90 mul   % d cl bl ab x g  | g = 0 or 180
      3 -1 roll      % d cl bl x g ab
      add            % d cl bl x ang

      rotate         % d cl bl x

      mul            % d cl bl'
      exch           % d bl' cl

      scale          % d
      exec           % 
      grestore       
    } /exec cvx 
  ] cvx 
} def 

%% picture -> picture
/turn {
  [                 % p [
    exch            % [ p
    /turn-box cvx   % [ p turn-box 
    exch            % [ turn-box p 
    /exec cvx       % [ turn-box p exec
  ] cvx             % { turn-box p exec }
} def

%% picture -> picture
/flip {
  [                % p [
    exch           % [ p
    /flip-box cvx  % [ p flip-box
    exch           % [ flip-box p 
    /exec cvx      % [ flip-box p exec 
  ] cvx            % { flip-box p exec }
} def

%% picture -> picture
/toss {
  [                % p [
    exch           % [ p
    /toss-box cvx  % [ p toss-box
    exch           % [ toss-box p 
    /exec cvx      % [ toss-box p exec 
  ] cvx            % { toss-box p exec }
} def

% Consumes: p1 p2 m n 
% Produces: p  
/above-ratio {
  [                % box * p1 p2 m n [
    5 1 roll       % box [ p1 p2 m n
    {
      1 index      % box p1 p2 m n m 
      add          % box p1 p2 m t
      div          % box p1 p2 f
      dup          % box p1 p2 f f 
      1            % box p1 p2 f f 1
      exch         % box p1 p2 f 1 f 
      sub          % box p1 p2 f f'
      dup          % box p1 p2 f f' f'
      3 1 roll     % box p1 p2 f' f f'
      6 -1 roll    % p1 p2 f' f f' box 
      dup          % p1 p2 f' f f' box box 
      7 1 roll     % box p1 p2 f' f f' box
      exch         % box p1 p2 f' f box f'  
      move-vert    % box p1 p2 f' f box'    (box' = box f' mv)
      exch         % box p1 p2 f' box' f 
      scale-vert   % box p1 p2 f' box1
      4 -1 roll    % box p2 f' box1 p1
      exec         % box p2 f'
      exch         % box f' p2 
      3 1 roll     % p2 box f'
      scale-vert   % p2 box2 
      exch         % box2 p2 
      exec         %
    } /exec cvx 
  ] cvx
} def

/above {
  1 1 above-ratio
} def 

% Consumes: p1 p2 m n 
% Produces: p  
/beside-ratio {
  [                % box * p1 p2 m n [
    5 1 roll       % box [ p1 p2 m n
    {
      1 index      % box p1 p2 m n m 
      add          % box p1 p2 m t
      div          % box p1 p2 f
      dup          % box p1 p2 f f 
      1            % box p1 p2 f f 1
      exch         % box p1 p2 f 1 f 
      sub          % box p1 p2 f f'
      exch         % box p1 p2 f' f
      dup          % box p1 p2 f' f f
      6 -1 roll    % p1 p2 f' f f box
      dup          % p1 p2 f' f f box box 
      3 2 roll     % p1 p2 f' f box box f 
      scale-hori   % p1 p2 f' f box box1 
      6 -1 roll    % p2 f' f box box1 p1 
      exec         % p2 f' f box 
      exch         % p2 f' box f
      move-hori    % p2 f' box'
      exch         % p2 box' f'
      scale-hori   % p2 box2 
      exch         % box2 p2 
      exec 
    } /exec cvx 
  ] cvx
} def

/beside {
  1 1 beside-ratio 
} def 

/quartet {              % nw ne sw se
  beside                % nw ne s 
  3 1 roll              % s nw ne 
  beside                % s n 
  exch                  % n s
  above                 % p 
} def

% Consumes: w m e 
% Produces: p'
/row {
  [                    % box * w m e [
    4 1 roll           % box [ w m e
    {                  % box w m e 
      beside           % box w me 
      1 2 beside-ratio % box p'
      exec             % 
    } /exec cvx 
  ] cvx     
} def

% Consumes: n m s 
% Produces: p'
/column {
  [                    % box * n m s [
    4 1 roll           % box [ n m s
    {                  % box n m s 
      above            % box n ms  
      1 2 above-ratio  % box p'
      exec             % 
    } /exec cvx 
  ] cvx     
} def

/nonet {
  [                % box * nw nm ne mw mm me sw sm se [
    10 1 roll       % box [ nw nm ne mw mm me sw sm se
    {              % box nw nm ne mw mm me sw sm se
      row          % box nw nm ne mw mm me s 
      7 1 roll     % box s nw nm ne mw mm me
      row          % box s nw nm ne m
      5 1 roll     % box m s nw nm n 
      row          % box m s n 
      3 1 roll     % box n m s 
      column       % box p'
      exec 
    } /exec cvx 
  ] cvx   
} def

% Consumes: p1 p2 
% Produces: p  
/over {
  [                % box * p1 p2 [
    3 1 roll       % box [ p1 p2 
    {              % box p1 p2
      2 index      % box p1 p2 box 
      exch         % box p1 box p2 
      exec         % box p1 
      exec         %
    } /exec cvx
  ] cvx
} def

% Consumes: p 
% Produces: p' 
/ttile {
  [                  % box * p [
    exch             % box [ p
    {                % box p
      dup            % box p p 
      toss flip      % box p pn
      dup            % box p pn pn  
      turn turn turn % box p pn pe
      over over      % box p'
      exec
    } /exec cvx
  ] cvx
} def

% Consumes: p 
% Produces: p' 
/utile {
  [                  % box * p [
    exch             % box [ p
    {                % box p
      toss flip      % box pn
      dup turn       % box pn pw
      dup turn       % box pn pw ps 
      dup turn       % box pn pw ps pe 
      over over over % box p'
      exec           %
    } /exec cvx
  ] cvx
} def 

% Consumes: p n 
% Produces: p'
/side {
  [                  % box * p n [
    3 1 roll         % box [ p n
    {                % box p n
      dup            % box p n n
      0 le           % box p n, n <= 0
      {
        pop pop      % box 
        /blank load  % box blank
      } 
      {              % box p n, n > 1
        1 sub        % box p n-1
        1 index      % box p n-1 p
        exch         % box p p n-1 
        side         % box p s
        dup          % box p s s 
        3 -1 roll    % box s s p 
        ttile        % box s s t 
        dup          % box s s t t
        turn         % box s s t t' 
        exch         % box s s t' t 
        quartet      % box q
      } ifelse
      exec           %
    } /exec cvx
  ] cvx
} def 

% Consumes: p n 
% Produces: p'
/corner {
  [                  % box * p n [
    3 1 roll         % box [ p n
    {                % box p n
      dup            % box p n n
      0 le           % box p n, n <= 0
      {
        pop pop      % box 
        /blank load  % box blank
      } 
      {              % box p n, n > 1
        1 sub        % box p n-1
        1 index      % box p n-1 p
        exch         % box p p n-1 
        2 copy       % box p p n-1 p n-1
        corner       % box p p n-1 c 
        3 1 roll     % box p c p n-1
        side         % box p c s 
        dup turn     % box p c s s' 
        4 -1 roll    % box c s s' p 
        utile        % box c s s' u
        quartet      % box p'
      } ifelse
      exec           %
    } /exec cvx
  ] cvx
} def 

% Consumes: p k
% Produces: p' 
/square-limit {
  [                  % box * p k [
    3 1 roll         % box [ p k
    {                % box p k
      2 copy         % box p k p k
      1 index        % box p k p k p 
      utile          % box p k p k u 
      5 1 roll       % box u p k p k 
      side           % box u p k z
      3 1 roll       % box u z p k 
      corner         % box u z c 
      dup turn       % box u z nw sw 
      dup turn       % box u z nw sw se 
      dup turn       % box u z nw sw se ne
      3 1 roll       % box u z nw ne sw se 
      5 -1 roll      % box u nw ne sw se n
      dup turn       % box u nw ne sw se n w 
      dup turn       % box u nw ne sw se n w s
      dup turn       % box u nw ne sw se n w s e
      6 1 roll       % box u nw ne e sw se n w s 
      4 1 roll       % box u nw ne e sw s se n w
      6 1 roll       % box u nw ne w e sw s se n
      7 1 roll       % box u nw n ne w e sw s se 
      9 -1 roll      % box nw n ne w e sw s se u 
      5 1 roll       % box nw n ne w u e sw s se 
      nonet          % box p'
      exec           %
    } /exec cvx
  ] cvx
} def


%%% PICTURES

/blank /pop load def 

/f-picture /draw-f load create-picture def

/george-picture /draw-george load create-picture def

/fh-picture /draw-hfish load create-picture def 

%%% BOXES

/small-box [ [100 200] [200 0] [0 200] ] def

/some-box [ [100 400] [400 0] [0 400] ] def

/skew-box [ [100 400] [200 20] [-30 400] ] def

/big-box [ [50 200] [500 0] [0 500] ] def

% some-box /fh-picture load exec 

% some-box /fh-picture load utile /blank load dup 2 index quartet exec 

% some-box /fh-picture load 3 corner exec

% some-box /fh-picture load turn turn turn exec 

% big-box /fh-picture load 3 square-limit exec 

% some-box /fh-picture load dup dup dup dup dup dup dup dup nonet exec 

% some-box /f-picture load toss exec  

% some-box /f-picture load dup turn 3 2 above-ratio exec

% some-box /f-picture load dup flip dup dup flip quartet exec 

% some-box /george-picture load dup turn turn flip beside exec

% some-box /george-picture load dup turn turn flip 1 index turn turn 2 index flip quartet exec
